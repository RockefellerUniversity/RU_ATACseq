<!DOCTYPE html>
<html>
  <head>
    <title>Analysis of ATAC-seq data in R and Bioconductor</title>
    <meta charset="utf-8">
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Analysis of ATAC-seq data in R and Bioconductor
### Rockefeller University, Bioinformatics Resource Centre
### <a href="http://rockefelleruniversity.github.io/RU_ChIPseq/" class="uri">http://rockefelleruniversity.github.io/RU_ChIPseq/</a>

---




---
## ATAC-seq

---
## ATAC-seq, MNase-seq and DNase-seq

&lt;div align="center"&gt;
&lt;img src="https://www.the-scientist.com/January2016/LT2_2.jpg" alt="offset" height="300" width="600"&gt;
&lt;/div&gt;

* DNase-seq - Enzymatic digestion to extract signal from open chromatin around transcription factor binding sites.

* MNase-seq - Enzymatic digestion to extract signal repesenting nucleosome positioning.

* ATAC-seq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.

---
# Working with ATAC-seq data in R/Bioconductor


In this session we will look at some of the basics of ATAC-seq processing in R using some publically available data.

We will look at the alignment, post-alignment processing and plotting of ATAC-seq data over TSSs.

---
### The Sequencing Data.

In the ATACseq session we will make use of three sets of published data.

The first dataset is from original ATAC-seq paper.

Transposition of native chromatin for multimodal regulatory analysis and personal epigenomics
Jason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf

In particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 
Data can be retrieved in fastq format from ENA  

* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)

---

For the second dataset we take ATAC-seq generated by Bing Ren at UCSD as part of the Encode consortium. 
Links to data and sample information are included in list below.

* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)

* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)

* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)

---
Finally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in this session so we can review some of the characteristics of ATAC-seq data alongside the same data processed by Encode's pipeline during the practical session.

The raw data and processed BAM file is available from Encodes portal

* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)

---
### The Reference Data

For ATAC-seq analysis we will require a few pieces of reference data. 

This includes-

* Reference genome in fasta format - We will retrieve these from BSGenome Bioconductor annotation packages.

* Gene models - We will retrieve these from TxDb Bioconductor annotation packages.

* Blacklists - Artefact regions specific to genomes. These can be found in [Encode portal here](https://www.encodeproject.org/annotations/ENCSR636HFF/)

---
### Processed Data.

We start with public sequencing data in links below and use reference data in Bioconductor.

Since some of these processing steps may take a little time i provide links to pre-processed results.

**Essentials**

BAM file and BAI index from our alignment/sorting/indexing.

* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  

* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. 

---
**Essentials**

Small BAM, peak calls and directory structure.

* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.

Once you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**

You should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. 
---
**Not essential**

Same as above but with BAMs for counting as well as small BAM, peak calls and directory structure.

* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.

Bigwigs for IGV.

* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. 

---

## Greenleaf dataset fastq to aligned data in BAM.

In this section we will work a little with the Greenleaf dataset. 

We will process one sample of the Greenleaf data from fastq to BAM to allow us to review some of the features of ATAC-seq data and to create some processed files for review and further analysis.

---

### Creating a reference genome

First we will need to create a reference genome to align our ATAC-seq data.  We can create a FASTA file for alignment as we did previously for the ChIPseq analysis.

Here as we are working with human data we use the **BSgenome.Hsapiens.UCSC.hg19** library for the hg19 genome build.


```r
library(BSgenome.Hsapiens.UCSC.hg19)
mainChromosomes &lt;- paste0("chr",c(1:21,"X","Y","M"))
mainChrSeq &lt;- lapply(mainChromosomes,
                     function(x)BSgenome.Hsapiens.UCSC.hg19[[x]])
names(mainChrSeq) &lt;- mainChromosomes
mainChrSeqSet &lt;- DNAStringSet(mainChrSeq)
writeXStringSet(mainChrSeqSet,
                "BSgenome.Hsapiens.UCSC.hg19.mainChrs.fa")
```

---

# Aligning Sequence Reads to the Genome.

Now we have a reference genome, we can align our ATAC-seq reads

As ATACseq data is typically paired we will need to make some minor adjustments to our alignment steps.

In QuasR we simply supply an additional column for the 2nd read pair.



```r
FileName1 &lt;- "ATAC_Data/ATAC_FQs/SRR891269_1.fastq.gz"
FileName2 &lt;- "ATAC_Data/ATAC_FQs/SRR891269_2.fastq.gz"
SampleName &lt;- "Myc_Mel_1"
sampleTable &lt;- data.frame(FileName1,FileName2,SampleName)
write.table(sampleTable,file="sampleTable.txt",sep="\t",
            quote=FALSE,row.names = FALSE)
```


```
##                                 FileName1
## 1 ATAC_Data/ATAC_FQs/SRR891269_1.fastq.gz
##                                 FileName2 SampleName
## 1 ATAC_Data/ATAC_FQs/SRR891269_2.fastq.gz  Myc_Mel_1
```

---

# Aligning Sequence Reads to the Genome.


We can now use the **qAlign()** function to align our data.

The **qAlign()** function requires the path to our sample table file and the path of a FASTA file to align sequence reads against.
 

```r
library(QuasR)
qAlign("sampleTable.txt","BSgenome.Hsapiens.UCSC.hg19.mainChrs.fa")
```

---

### Creating Rsubread index

Index building is part of the **QuasR** alignment process but for Rsubread we must build our index prior to Rsubread's alignment steps.

Rsubread's [**buildindex()** function simply takes the parameters of our desired index name and the FASTA file to build index from.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignmentInBioconductor.html#34). 

Here i additional specify the parameter **indexSplit** as TRUE in conjunction with **memory** parameter set to 1000 (1000MB) to control memory usage in Rsubread alignment step.


```r
library(Rsubread)
buildindex("BSgenome.Hsapiens.UCSC.hg19.mainChrs",
           "BSgenome.Hsapiens.UCSC.hg19.mainChrs.fa",
           indexSplit = TRUE,
           memory = 1000)
```

---
### Aligning Sequence Reads to the Genome.

Here we can use a standard alignment for DNA (as for ChIPseq) but we increase the maximum allowed fragment length to capture long fragments representing poly-nucleosome signal. 

The maximum allowed fragment length set here is based on parameters used within Greenleaf study. To control maximum allowed fragment lengths i set the **maxFragLength** parameter to 2000. I also set **unique** parameter to TRUE to only include uniquely mapping reads.




```r
read1 &lt;- "ATAC_Data/ATAC_FQs/SRR891269_1.fastq.gz"
read2 &lt;- "ATAC_Data/ATAC_FQs/SRR891269_2.fastq.gz"
outBAM &lt;- "ATAC_50K_2.bam"

align("BSgenome.Hsapiens.UCSC.hg19.mainChrs",
      readfile1=read1,readfile2=read2,
      output_file = outBAM,
      nthreads=2,type=1,
      unique=TRUE,maxFragLength = 2000)
```
---
### Sorting and Indexing

Following alignment we would want to sort and index our BAM file for use with external tool.

First we sort our aligned data by sequence order (not Read Name here).

We then index our file allowing for rapid access of particular genomic locations by other programs (e.g IGV, Samtools) and by R/Bioconductor packaes we will use.



```r
library(Rsamtools)
sortedBAM &lt;- file.path(dirname(outBAM),
                       paste0("Sorted_",basename(outBAM))
                       )

sortBam(outBAM,gsub("\\.bam","",basename(sortedBAM)))
indexBam(sortedBAM)
```


```r
sortedBAM &lt;- "~/Downloads/demo/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam"
```

---
### Distribution of mapped reads

In ATAC-seq we will want to check the distribution of mapped reads across chromosomes.

ATAC-seq is known have high signal on the mitochondrial chromosomes and so we can check for that here.


```r
library(Rsamtools)

mappedReads &lt;- idxstatsBam(sortedBAM)
```

---
### Distribution of mapped reads

We can now use the mapped reads data frame to make a barplot of reads across chromosomes.

In this example, we see a case where the mapping rate to mitochondrial genome is high.


```r
library(ggplot2)

ggplot(mappedReads,aes(seqnames,mapped,fill=seqnames))+
  geom_bar(stat="identity")+coord_flip()
```

![](RU_ATAC_files/figure-html/quickMappingStatsPerChromosomes-1.png)&lt;!-- --&gt;

---
## Greenleaf dataset post-alignment processing.

Now we have the processed the ATAC-seq paired-end data we can start to work with alignments.

First we will identify the expected fragment length distribution for ATAC-seq data. We read our newly aligned data using the GenomicAlignments package. 

Here we only wants read which are properly paired so we will use the **ScanBamParam()** and **scanBamFlag()** functions to control what will be read into R.

We set the **scanBamFlag()** function parameters **isProperPair** to TRUE so as to only read in reads paired in alignment within our preset max fragment length (2000bpp)


```r
library(GenomicAlignments)
flags=scanBamFlag(isProperPair =TRUE)
```

---
## Greenleaf dataset post-alignment processing.

We can now use these flags with the **ScanBamParam()** function to read in only properly paired reads. 

We additionally specify information to be read into R using the **what** parameter. Importantly we specify the insert size information - **isize**.
To reduce memory footprint we read only information from chromosome 20 by specifying a GRanges object to **which** parameter.



```r
myParam=ScanBamParam(flag=flags,
                   what=c("qname","mapq","isize"),
                   which=GRanges("chr20", IRanges(1,63025520)))
myParam
```

```
## class: ScanBamParam
## bamFlag (NA unless specified): isProperPair=TRUE
## bamSimpleCigar: FALSE
## bamReverseComplement: FALSE
## bamTag:  
## bamTagFilter:
## bamWhich: 1 ranges
## bamWhat: qname, mapq, isize
## bamMapqFilter: NA
```


---
## Greenleaf dataset post-alignment processing.

Now we have set up the **ScanBamParam** object, we can use the **readGAlignmentPairs()** function to read in our paired-end ATAC-seq data in a similar way to how we read in single-end ChIP-seq data using the **readGAlignments()** function.

The resulting object is a **GAlignmentPairs** object.


```r
atacReads &lt;- readGAlignmentPairs(sortedBAM,
                                 param=myParam)
class(atacReads)
```

```
## [1] "GAlignmentPairs"
## attr(,"package")
## [1] "GenomicAlignments"
```

---
## Greenleaf dataset post-alignment processing.

The **GAlignmentPairs** object contains information on our paired reads. 

It stores information on each read in a pair in parallel **GAlignments** objects.


```r
atacReads[1:2,]
```

```
## GAlignmentPairs object with 2 pairs, strandMode=1, and 0 metadata columns:
##       seqnames strand :         ranges --         ranges
##          &lt;Rle&gt;  &lt;Rle&gt; :      &lt;IRanges&gt; --      &lt;IRanges&gt;
##   [1]    chr20      + : [60000, 60029] -- [60361, 60410]
##   [2]    chr20      + : [60000, 60029] -- [60361, 60410]
##   -------
##   seqinfo: 25 sequences from an unspecified genome
```

---
## Greenleaf dataset post-alignment processing.

We access the **GAlignments** objects using the **first()** and **second()** accessor functions to gain information on the first or second read respectively.


```r
read1 &lt;- first(atacReads)
read2 &lt;- second(atacReads)
read2[1,]
```

```
## GAlignments object with 1 alignment and 3 metadata columns:
##       seqnames strand       cigar    qwidth     start       end     width
##          &lt;Rle&gt;  &lt;Rle&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
##   [1]    chr20      -         50M        50     60361     60410        50
##           njunc |              qname      mapq     isize
##       &lt;integer&gt; |        &lt;character&gt; &lt;integer&gt; &lt;integer&gt;
##   [1]         0 | SRR891269.17032370        40      -431
##   -------
##   seqinfo: 25 sequences from an unspecified genome
```

---
### Retrieving insert sizes

Now we have read in the paired aligned data into R, we can retreive the insert sizes from the elementMetadata attached to **GAlignments** objects of each read pair.

Since properly paired reads will have the same insert size length we extract insert sizes from read1.


```r
atacReads_read1 &lt;- GenomicAlignments::first(atacReads)
insertSizes &lt;- abs(elementMetadata(atacReads_read1)$isize)
head(insertSizes)
```

```
## [1] 431 431 228  60 228 176
```
---
### Plotting insert sizes

ATAC-seq should represent a mix of fragment lengths corresponding to nucleosome free, mononucleosome and poly-nucleosome fractions.

We can use the newly acquired insert lengths for chromosome 20 to plot the distribution of all fragment lengths.



```r
library(ggplot2)
fragLenSizes &lt;- table(insertSizes)
toPlot &lt;- data.frame(InsertSize=as.numeric(names(fragLenSizes)),
                            Count=as.numeric(fragLenSizes))
fragLenPlot &lt;- ggplot(toPlot,aes(x=InsertSize,y=Count))+geom_line()
```
---
### Plotting insert sizes



```r
fragLenPlot+theme_bw()
```

![](RU_ATAC_files/figure-html/processData_plottingFragmentLengths2-1.png)&lt;!-- --&gt;
---
### Plotting insert sizes



```r
fragLenPlot + scale_y_continuous(trans='log2')+theme_bw()
```

![](RU_ATAC_files/figure-html/processData_plottingFragmentLengths3-1.png)&lt;!-- --&gt;


---
### Plotting insert sizes with Greenleaf open, mono- and di-nucleosome profiles

This looks very similar to the image from the Greenleaf paper.

We can now annotate our nucleosome free (&lt; 100bp), mono-nucleosome (180bp-247bp) and di-nucleosome (315-437) as in the Greenleaf study.


```r
fragLenPlot+ scale_y_continuous(trans='log2')+
  geom_vline(xintercept = c(180,247),colour="red")+
  geom_vline(xintercept = c(315,437),colour="darkblue")+
  geom_vline(xintercept = c(100),colour="darkgreen")+theme_bw()
```

![](RU_ATAC_files/figure-html/processData_plottingFragmentLengths24-1.png)&lt;!-- --&gt;

---
### Subsetting ATAC-seq reads files by insert sizes.

We may wish to divide our aligned reads into reads representing nucleosome free and nucleosome occupied. 

Here we create BAM files for the reads representing nucleosome free, mono and di nucleosome by using insert sizes to filter read.


```r
atacReads_Open &lt;- atacReads[insertSizes &lt; 100,]
atacReads_MonoNuc &lt;- atacReads[insertSizes &gt; 180 &amp;
                                 insertSizes &lt; 240,]
atacReads_diNuc &lt;- atacReads[insertSizes &gt; 315 &amp;
                               insertSizes &lt; 437,]
```
---
### Creating BAM files split by insert sizes.

The resulting reads can be written back to BAM files for use in other parts of our analysis or for visualisation in programs such as IGV by functions in the rtracklayer package.



```r
openRegionBam &lt;- gsub("\\.bam","_openRegions\\.bam",sortedBAM)
monoNucBam &lt;- gsub("\\.bam","_monoNuc\\.bam",sortedBAM)
diNucBam &lt;- gsub("\\.bam","_diNuc\\.bam",sortedBAM)

library(rtracklayer)
export(atacReads_Open,openRegionBam,format = "bam")
export(atacReads_MonoNuc,monoNucBam,format = "bam")
#export(atacReads_Open,diNucBam,format = "bam")
```
---
### Creating an open region bigWig.

We can make it significantly quicker to review the pile-up of ATAC-seq signal in a genome browser by creating a bigWig file.

Additional normalisation to total mapped reads could be applied at this point.


```r
openRegionBigWig &lt;- gsub("\\.bam","_openRegions\\.bw",sortedBAM)
openRegionRPMBigWig &lt;- gsub("\\.bam","_openRegionsRPM\\.bw",sortedBAM)
atacFragments_Open &lt;- granges(atacReads_Open)
myCoverage &lt;- coverage(atacFragments_Open,
                       weight = (10^6/length(atacFragments_Open)))
export.bw(,openRegionBigWig)
```
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
