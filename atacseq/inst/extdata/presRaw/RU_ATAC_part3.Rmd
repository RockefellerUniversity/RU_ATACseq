---
title: "ATACseq In Bioconductor <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_ATACseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
require(SummarizedExperiment)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# ATACseq (part 2)

---
"    
  )
  
}

```

```{r setup, include=FALSE}
library(motifmatchr)
library(MotifDb)
library(JASPAR2020)

```


---

## Data

In this session we will also keep working with the larger dataset from the ENCODE consortium generated by Bing Ren at UCSD. This dataset has multiple samples for multiple tissues (Liver, Kidney and Hindbrain), allowing us to perform a differential analysis on open regions.

More details are [here](https://rockefelleruniversity.github.io/RU_ATACseq/presentations/slides/RU_ATAC_part2#5)


---
## ATACseq

<div align="center">
<img src="imgs/mnATAC.jpg" alt="offset" height="300" width="600">
</div>

* ATACseq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.

---
## ATACseq

Unlike with ChIPseq where we know the target of IP, with ATACseq we know that a region is open/accessible but have no knowledge of what transcription factors may be present.

We briefly saw at the end of our last session how we may scan for a specific motif under our peaks using **matchPWM**.

In the upcoming sessions we will review how we can investigate motifs in ATACseq using motifmatchr.


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Motif Databases

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Motif Databases

---
"    
  )
  
}
```

## Known Motif sources

Bioconductor provides two major sources of motifs as database packages.

These include:

 * The [MotifDb](https://www.bioconductor.org/packages/release/bioc/html/MotifDb.html) package.
 * The JASPAR databases, [JASPAR2020](https://www.bioconductor.org/packages/release/data/annotation/html/JASPAR2020.html) being latest.


---
## MotifDb

The MotifDB package collects motif information from a wide range of sources and stores them in a DB object for use with other Bioconductor packages.

```{r,eval=TRUE}
library(MotifDb)
MotifDb
```




---
## MotifDb

MotifDb object is special class of object called a **MotifList**.


```{r,eval=TRUE}
class(MotifDb)
```


---
## MotifDb

Like standard List objects we can use length and names to get some information on our object


```{r,eval=TRUE}
length(MotifDb)
MotifNames <- names(MotifDb)
MotifNames[1:10]
```

---
## Accesing MotifDb contents

We can also access information directly from our list using standard list accessors.

Here a **[** will subset to a single MotifList. Now we can see the information held in the MotifList a little more clearly.

```{r,eval=TRUE}
MotifDb[1]
```



---
## Accesing MotifDb contents

A **[[** will subset to object within the element as with standard lists. Here we extract the position probability matrix.


```{r,eval=TRUE}
MotifDb[[1]]
colSums(MotifDb[[1]])
```

---
## Accesing MotifDb contents

We can extract a DataFrame of all the motif metadata information using the **values()** function.


```{r,eval=TRUE}
values(MotifDb)[1:2,]
```

---
## Accesing MotifDb contents

We can use the **query** function to subset our MotifList by infomation in the metadata.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,"CTCF")
CTCFMotifs
```

---
## Accesing MotifDb contents

For more specific queries, multiple words can be used for filtering.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,c("CTCF","hsapiens","jaspar2018"))
CTCFMotifs
```


---
## JASPAR2020 package

The JASPAR packages are updated more frequently and so may contain motifs not characterized in the MotifDb package.

We can load the **JASPAR** package as usual and review the object as before.

```{r,eval=TRUE}
library(JASPAR2020)
JASPAR2020
```

---
## JASPAR2020 and TFBSTools

To interact with JASPAR package we will make use of the **TFBSTools** package from the same lab.

Whereas the JASPAR package holds the information on Motifs and Position Probability Matrices (PPMs), TFBSTools has the functionality to manipulate and interact with these tools.

Three useful functions available from TFBStools to interact with the JASPAR databases are the **getMatrixSet**, **getMatrixByID** and **getMatrixByID**.


```{r,eval=TRUE, message=F, warning=F}
library(TFBSTools)
?getMatrixByID
```


---
## TFBSTools for TFs

The **getMatrixByID** and **getMatrixByName** take the JASPAR DB object and a JASPAR ID or transcription factor name respectively.

Here we are using the transcription factor GATA2. The result is a new object class **PFMatrix**.

```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByName(JASPAR2020,"GATA2")
class(GATA2mat)
```

---
## TFBSTools for motifs

JASPAR IDs are unique, so we can use them to select the exact motif we wanted.
```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByID(JASPAR2020,"MA0036.2")
```

---
## TFBSTools for motifs

List accessors will not work here but we can retrieve names using the **ID** function.

```{r,eval=TRUE,echo=TRUE}
ID(GATA2mat)
```


---
## Position Frequency Matrix

To get hold of the Position Frequency Matrix (PFM) we can use the **Matrix** or **as.matrix** functions.

```{r,eval=TRUE}
myMatrix <- Matrix(GATA2mat)
myMatrixToo <- as.matrix(myMatrix)
myMatrix
```

---
## TFBSTools for motif sets

We can also use the **getMatrixSet()** function to retrieve sets of motifs. We can specify a list of options for motifs we want to retrieve. 

To see the available filters use the help for getMatrixSet() function, ?getMatrixSet.

```{r,eval=TRUE}
opts <- list()
opts[["collection"]] <- "CORE"
opts[["tax_group"]] <- "vertebrates"
motifList <- getMatrixSet(JASPAR2020, opts)
   
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Visualizing motifs

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Visualizing motifs

---
"    
  )
  
}
```

## Visualizing motifs

The seqLogo package offers a simple and intuitive way of visualizing our base frequencies within out motifs using the **seqLogo** function.

A simple seqLogo shows the relative frequency of a base at each motif position by the relative size of the base compared to other bases at the same position. 

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
require(seqLogo)
CTCFMotifs <- query(MotifDb,"CTCF")
seqLogo::seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```



---
## Visualizing motifs

To create a seqLogo we must supply a PPM to the **seqLogo** function. Here we grab a PPM straight from MotidDb for CTCF. 

Here we set the **ic.scale** to FALSE to show the probability across the Y-axis

```{r,eval=TRUE}
library(seqLogo)
CTCFMotifs <- query(MotifDb,"CTCF")
seqLogo::seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```


---
## Visualizing motifs

It may be useful to plot the probabilities as information content. Information content here will range from 0 to 2 Bits. Positions with equal probabilities for each base will score 0 and positions with only 1 possible base will score 2. 

This allows you to quickly identify the important bases.

```{r,eval=TRUE}
seqLogo::seqLogo(CTCFMotifs[[1]])
```

---

## Visualizing motifs

The TFBSTools package and JASPAR provide us with point frequency matrices which we can't use directly in the seqLogo package

```{r,eval=TRUE}
myMatrix
```

---

## Visualizing motifs

We can convert our point frequency matrix to a point probabilty matrix by simply dividing columns by their sum.

```{r,eval=TRUE,echo=TRUE, fig.height=4,fig.width=6}
ppm <- myMatrix/colSums(myMatrix)
ppm
```

---

## Visualizing motifs

We can then plot the result matrix using seqLogo.

```{r,eval=TRUE,echo=TRUE, fig.height=4,fig.width=6}
seqLogo::seqLogo(ppm)
```

---
## Visualizing motifs

Fortunately, TFBSTools has its own version of seqLogo function we can use with one of its own **ICMatrix** classes. We simply need to convert our object with the **toICM()** function.

```{r,eval=TRUE,echo=TRUE, fig.height=4,fig.width=6}
GATA2_IC <- toICM(GATA2mat)
TFBSTools::seqLogo(GATA2_IC)
```

---

## Visualizing with ggplot

We can also use a ggplot2 style grammar of graphics with the **ggseqlogo** package.

```{r,eval=TRUE,echo=TRUE, fig.height=4,fig.width=6}
library(ggseqlogo)
library(ggplot2)
ggseqlogo(myMatrix)+theme_minimal()
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Identifying Motifs in ATAC

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Identifying Motifs in ATAC

---
"    
  )
  
}
```


## Known motif identification

Since ATACseq only tells us which regions are open/accessible, we can use motifs within our ATACseq peak regions to identify potential transcription factors which may be acting there.

The databases such as MotifDb and JASPAR2020, provide sets of known motif patterns for us to use our motif identification.

---

## motifmatchr

To identify known motifs we will use the **motifmatchr** package which is a wrapper for the MOODS c++ library.

This means that motifmatchr offers us a fast methods to identify motifs within our ATACseq data.

We will use motifmatchr/MOODs with a default p-value cut-off.

---

## motifmatchr

First we can retrieve a sensible set of motifs to scan for within our mouse tissue ATACseq data.

Here we retrieve the vertebrate, JASPAR CORE motifs. We additional specify *all_versions* is FALSE to only include the latest version of a motif.

```{r}
opts <- list()
opts[["tax_group"]] <- "vertebrates"
opts[["collection"]] <- "CORE"
opts[["all_versions"]] <- FALSE
motifsToScan <- getMatrixSet(JASPAR2020,opts)

```


---

## motifmatchr

The motifmatchr package main function is **matchMotifs()**.

As with many Bioconductor functions , **matchMotifs** makes use of other Bioconductor objects such the BSGenome, GRanges and summarizedExperiment objects.

We can review the full functionality by reading the help for matchMotifs, ?matchMotifs.

---

## ENCODE ATAC data

We need some data to review so we can make use of the ENCODE mouse tissue ATAC data.

We can load in the counts in a summarizedExperiment object from the **data** directory.

```{r}
load("data/myCounts.RData")
myCounts
```


---

## ENCODE ATAC peaks

We can retrieve the ranges of our peaks directly from our SummarizedExperiment object by using the standard accessor **rowRanges**.

```{r}
peakRanges <- rowRanges(myCounts)
peakRanges[1,]
```

---

## ENCODE ATAC peaks

We can use the **getSeq()** function to extract sequences from a BSGenome object using a GRanges object to define the regions of interest. This is a similar approach to *de novo* motif discovery for [ChIPseq.](https://rockefelleruniversity.github.io/RU_ChIPseq/presentations/slides/ChIPseq_In_Bioconductor3.html#33)

We load the BSgenome.Mmusculus.UCSC.mm10 library and re-center our peaks to 100bp using the resize function. Once resized we can extract the required sequences using the **getSeq()** function.

```{r}
library(BSgenome.Mmusculus.UCSC.mm10)
peakRangesCentered <- resize(peakRanges,fix = "center",width = 100)
peakSeqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10,peakRangesCentered)
names(peakSeqs) <- as.character(peakRangesCentered)
peakSeqs
```

---
## Finding motif positions

As we saw in its help, The matchMotifs function can provide output of motif matches as matches, scores or positions.

Here we scan for 4 selected motifs from JASPAR2020 using the sequence under the first 100 ATACseq peaks and specify the out as **positions**.

```{r}
motif_positions <- matchMotifs(motifsToScan[1:4], peakSeqs[1:100],out="positions")
class(motif_positions)
length(motif_positions)
```

---
## Finding motif positions

The result contains a list of the same length as the number of motifs tested.

Each element contains a IRangeslist with an entry for every sequence tested and a IRanges of motif positions within the peak sequences.

```{r}
motif_positions$MA0029.1
```

---

## Finding motif positions

We can unlist our IRangeslist to a standard list for easier working.
```{r}

MA0029hits <- motif_positions$MA0029.1
names(MA0029hits) <- names(peakSeqs[1:100])
unlist(MA0029hits, use.names = TRUE)
```


---

## Finding motif hits

We may simply want to map motifs to their ATACseq peaks.

To do this we can set the **out** parameter to **matches**.  This will return a SummarizedExperiment object.

```{r}
motifHits <- matchMotifs(motifsToScan, peakSeqs, out="matches")
class(motifHits)
motifHits
```

---
## Finding motif hits

We can retrieve a matrix of matches by motif and peak using the motifMatches function.

```{r}
mmMatrix <- motifMatches(motifHits)
dim(mmMatrix)
mmMatrix[1:8,1:8]
```

---

## Finding motif hits

Although a sparse matrix, we can still use our matrix operations to extract useful information from this object.

We can use the **colSums()** to identify the total occurrence of motifs in our peak sequences.

```{r,eval=F, echo=T}
totalMotifOccurence <- colSums(mmMatrix)
totalMotifOccurence[1:4]
```

```{r,eval=T, echo=F}
my_mat<-apply(data.matrix(mmMatrix),2,sum)
names(my_mat)<-colnames(mmMatrix)
my_mat[1:4]
```

---

## Finding motif hits

We can also identify peaks which contain a hit for a selected motif.


```{r,eval=T}
peaksWithMA0912 <- peakRangesCentered[mmMatrix[,"MA0912.2"] == 1]
peaksWithMA0912
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# summarizing ATAC signal to Motifs

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# summarizing ATAC signal to Motifs

---
"    
  )
  
}
```

## summarizing ATAC signal to Motifs

The **chromVar** package allows for the summarization of ATACseq signal changes to the motifs within peaks.

With this summarization we can potentially identify which motifs may have an important role in a set of ATAC samples compared to other samples.

The chromVar package comes from the same lab and author as the motifmatchr package and so will work well together.

First we load the library.


```{r}
library(chromVAR)
```

---

## Setting up for chromVar

To identify motifs for chomVar we will use motifMatchr with a different set of inputs. 

Here we will provide our __*Ranged*SummarizedExperiment__ object contaitng our counts over peaks directly to the matchMotifs function. 

First we will remove any peaks with less than 5 reads across all samples.


```{r}
myCounts <- myCounts[rowSums(assay(myCounts)) > 5,]
```

---

## Correct GC bias

Next we can correct for any potential GC bias which may have arisen in sequencing. Previously we have seen that we have GC bias observable in our FastQ quality checks. 

For comparing across differing sets of peaks with differing sequences compositions we will need to correct for this bias. We can use the **addGCBias** and specify our genome as a BSgenome object to correct in chromVar.

```{r}
myCounts <- addGCBias(myCounts,
                    genome = BSgenome.Mmusculus.UCSC.mm10)
```


---

## ID motifs in peaks

Having corrected for bias, we can use the matchMotifs function again to identify motifs under our ATACseq peaks. 

Here we supply our __*Ranged*SummarizedExperiment__ of counts in peaks and the genome of interest to the **matchMotifs** function and use the default **out** of *matches*.

```{r}
motif_ix <- matchMotifs(motifsToScan, myCounts,
                        genome = BSgenome.Mmusculus.UCSC.mm10)
motif_ix
```

---

## Run chromVar

Following the identification of motifs in our peaks, we can perform the summarization of ATACseq signal to motifs using the **computeDeviations** and the **computeVariability** functions.

```{r,eval=FALSE}
deviations <- computeDeviations(object = myCounts, annotations = motif_ix)
variability_Known <- computeVariability(deviations)
```

```{r,include=FALSE}
load("data/deviations.RData")
load("data/variability.RData")
```


---

## chromVar deviations

The deviations result contains a SummarizedExperiment object with the Z-scores showing the enrichment for ATACseq signal in each sample for every motif.

```{r}
devZscores <- deviationScores(deviations)
devZscores[1:2,]
```


---

## chromVar variability

The variability result contains the ranking of motifs by their variability across samples. Highly variable motifs may indicate motifs associated with a particular sample group or variable across all groups.

```{r}
variability_Known <- variability_Known[order(variability_Known$p_value),]
variability_Known[1:10,]
```

---

## chromVar results

We can use the results from the variability with our Z-score deviations to identify in which sample our motifs are enriched.

```{r}
topVariable <- variability_Known[1:20,]
devTop <- merge(topVariable[,1,drop=FALSE],devZscores,by=0)
devTop[1:2,]
```


---

## chromVar results

A useful way to visualize these results is using a heatmap. Although we cover this in a later session, here we can use the **pheatmap** library with default settings to illustrate where our most variable motifs are active. 

```{r}
devToPlot <- as.matrix(devTop[,-c(1:2)])
rownames(devToPlot) <- devTop[,2]
library(pheatmap)
pheatmap(devToPlot)
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Identifying Motifs *de novo* in ATAC

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Identifying Motifs *de novo* in ATAC

---
"    
  )
  
}
```


## *De novo* motif discovery

So far we have reviewed how to identify known motifs within our ATACseq peaks.

In our [ChIPseq training](https://rockefelleruniversity.github.io/RU_ChIPseq/presentations/slides/ChIPseq_In_Bioconductor3.html#28) we cover howt we can use the Meme-ChIP software to perform *De novo* motif identification.

Here we wll use the Meme-ChIP software in a discriminative mode to identify *De novo* motifs enriched in one set of samples over another.


---

## Differential peaks

First we will need to identify a set of peaks enriched for ATACseq signal in one group over another. To do this we will use DESeq2 to identify ATACseq peaks enriched in 1 set over another.

We can load our Liver, Kidney and Brain counts from earlier into a DEseq object for differential analysis.

```{r}
require(DESeq2)
load("data/myCounts.RData")
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney",
                  "Liver","Liver"))
colData(myCounts) <- DataFrame(data.frame(Group,row.names=colnames(myCounts)))
dds <- DESeqDataSet(myCounts,design=~Group)
dds <- DESeq(dds)
```

---

## Differential peaks

We can then use the DESeq2 function **results** to identify differential ATAC regions and set the **format** parameter to **GRanges** to allow the return of the result as a GRanges object.

```{r}
myRes <- results(dds,contrast = c("Group","Liver","Kidney"),format = "GRanges")
myRes <- myRes[order(myRes$padj),]
upRegions <- myRes[myRes$log2FoldChange > 0][1:1000] 
downRegions <- myRes[myRes$log2FoldChange < 0,][1:1000]
upRegions
```

---

## Resize peaks

For Meme-ChIP we will want to resize the regions to 100bp. By default Meme-ChIP will perform this trimming for us but to ensure it is in the centre we will do this upfront.

```{r}

upRegions <- resize(upRegions,fix = "center",width = 100)
downRegions <- resize(downRegions,fix = "center",width = 100)
```

---

## Peak sequences

We can now use the **getSeq** function as previously to extract the signal from around within the GRange regions and write to a FASTA file for use in Meme-ChIP using the **writeXStringSet** function.

```{r}
library(BSgenome.Mmusculus.UCSC.mm10)
upStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,upRegions)
downStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,downRegions)
names(upStrings) <- as.character(upRegions)
names(downStrings) <- as.character(downRegions)
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")
```

---

## Meme-ChIP

We can then submit the sample to the Meme-ChIP online submission form found [here](http://meme-suite.org/tools/meme-chip). 

In contrast to for ChIPseq, here we will run this in Differential mode to compare our sequences in Liver enriched regions to those depleted in Liver.

The results can be found in **data/memeResult_LiverVsBrain**


---

## Using *De novo* motifs

We may want to use the motifs discovered by Meme-ChIP in other Bioconductor software.

To do this we can use the **universalmotif** package.

```{r}
library(universalmotif)
```


---
## Importing motifs

The **universalmotif** package provides lots of useful functions for importing motif sets. 

One useful and relevant function is the  **read_meme()** function.

```{r}
memeMotifs <- read_meme("data/memeResult_LiverVsBrain/combined.meme")
memeMotifs
```

---

## Importing motifs

The **universalmotif** package also provides functions to convert between motif objects from different package. Here we convert to TFBStools motif objects.

```{r}
memeMotifsTFBStools <- convert_motifs(memeMotifs,"TFBSTools-PWMatrix")
memeMotifsTFBStools
```

---

```{r,eval=FALSE,echo=FALSE}
require(tidyverse)
require(DESeq2)
load("/Volumes/TomBackup/Temp/rui_ATAC_IL12combined_hg38/salmon/Antibody_ATAC_fromMACSisBlacklisted/ATAC/dds.RData")
ddsFilt <- dds[,colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm")]
colData(ddsFilt) <- colData(dds)[colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm"),]
colData(ddsFilt)$Group <- droplevels(colData(ddsFilt)$Group)
dds <- DESeq(ddsFilt)
myRes <- results(dds,contrast = c("Group","ATAC_Control","ATAC_Tbet_mm"))
myRes <- myRes[order(myRes$padj),]
upRegions <- rownames(myRes)[myRes$log2FoldChange > 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
# upRegions <- rownames(myRes)[myRes$log2FoldChange > 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
downRegions <- rownames(myRes)[myRes$log2FoldChange < 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges

# DownRegions <- rownames(myRes)[myRes$log2FoldChange < 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges


library(BSgenome.Hsapiens.UCSC.hg38)
upStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(upRegions,fix = "center",width = 100))
downStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(downRegions,fix = "center",width = 100))
names(upStrings) <- as.character(resize(upRegions,fix = "center",width = 100))
names(downStrings) <- as.character(resize(downRegions,fix = "center",width = 100))
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")


require(motifmatchr)
require(JASPAR2018)


db <- file.path(system.file("extdata", package="JASPAR2018"),
                "JASPAR2018.sqlite")
opts <- list()
opts[["tax_group"]] <- "vertebrates"
opts[["collection"]] <- "CORE"
opts[["all_versions"]] <- FALSE
require(TFBSTools)
motifs <- getMatrixSet(db,opts)



motif_ixUp <- matchMotifs(motifs, upStrings)
motif_ixDown <- matchMotifs(motifs, downStrings)
totalsUp <- colSums(assay(motif_ixUp))
totalsDow <- colSums(assay(motif_ixDown))
total <- data.frame(totalsUp,totalsDow)
total[total == 0] <- 1
total$Diff <- total$totalsUp/total$totalsDow
total[order(total$Diff,decreasing = TRUE),]

IDtoGRanges <- function(IDs,asIGV=FALSE){
  if(!asIGV){
    IDmat <- data.frame(matrix(unlist(strsplit(IDs,":")),ncol = 4,byrow = T)[,-1])
    newSe <- GRanges(IDmat$X1,IRanges(as.numeric(as.vector(IDmat$X2)),as.numeric(as.vector(IDmat$X3))))
  }
  newSe
}

load("data/myCounts.RData")
# newDDS <- SummarizedExperiment(counts(dds,normalized=TRUE),
#                                rowData=NULL,
#                                rowRanges=IDtoGRanges(rownames(counts(dds))),
#                                colData= colData(dds) %>%
#                                  as.data.frame %>%
#                                  cbind(data.frame(depth=colSums(counts(dds,normalized=FALSE)))) %>%
#                                  dplyr::select(-sizeFactor)
# )

newDDS <- myCounts
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney",
                  "Liver","Liver"))
colData(newDDS) <- DataFrame(data.frame(Group,row.names=colnames(myCounts)))
require(DESeq2)
require(tidyverse)
atacDDS <- DESeqDataSetFromMatrix(assay(myCounts),
                                  colData(newDDS),
                                  ~Group,
                                  rowRanges=rowRanges(myCounts))
atacDDS <- DESeq(atacDDS)
myRes <- results(atacDDS,contrast = c("Group","Liver","Kidney"),format = "GRanges")
myRes <- myRes[order(myRes$padj),]
upRegions <- myRes[myRes$log2FoldChange > 0][1:1000] 
downRegions <- myRes[myRes$log2FoldChange < 0,][1:1000]

library(BSgenome.Mmusculus.UCSC.mm10)
upStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,resize(upRegions,fix = "center",width = 100))
downStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,resize(downRegions,fix = "center",width = 100))
names(upStrings) <- as.character(resize(upRegions,fix = "center",width = 100))
names(downStrings) <- as.character(resize(downRegions,fix = "center",width = 100))
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")

# names(sxs) <- gsub("\\s.*","",names(sxs))
assayNames(newDDS) <- "counts"
require(chromVAR)
newDDS <- newDDS[rowSums(assay(newDDS)) > 5,]
require(BSgenome.Mmusculus.UCSC.mm10)
newDDS <- addGCBias(newDDS,
                    genome = BSgenome.Mmusculus.UCSC.mm10)

motif_ix <- matchMotifs(motifs, newDDS,
                        genome = BSgenome.Mmusculus.UCSC.mm10)
dev_Known <- computeDeviations(object = newDDS, annotations = motif_ix)

variability_Known <- computeVariability(dev_Known) %>% arrange(p_value)

plotVariability(variability_Known, use_plotly = FALSE)
datatable(variability_Known)

temp <- deviationScores(dev_Known)
colnames(temp) <- paste0("Var_",colnames(temp))
mapOfIDs <- data.frame(id=names(rowData(dev_Known)$name),name=unname(rowData(dev_Known)$name))
sevew <- merge(mapOfIDs,temp,by.x=1,by.y=0)
sevew <- merge(variability_Known,sevew,by.x=1,by.y=2)
sigZ <- sevew %>% arrange(p_value) %>% 
  head(n=20) %>%
  mutate(newName=name) %>%
  dplyr::select(newName,starts_with("Var_")) %>%
  tibble::column_to_rownames("newName")
pheatmap(sigZ)
```

---
## Time for an exercise!

Exercise on ATACseq data can be found [here](../../exercises/exercises/ATACseq_part3_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/ATACseq_part3_answers.html)



