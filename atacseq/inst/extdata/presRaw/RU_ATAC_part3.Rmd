---
title: "ATACseq In Bioconductor <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_ATACseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# ATACseq (part 2)

---
"    
  )
  
}

```

```{r setup, include=FALSE}
library(motifmatchr)
library(MotifDb)
library(JASPAR2020)

```

## Greenleaf dataset characterisation and open region finding

In this section we will work a little more with the Greenleaf dataset. 

We will characterise Greenleaf data signal around TSS regions and identify and annotated open regions as peak calls using MACS2.

At the end of the session we will look at plotting transposase cut-sites around DNA binding proteins.

---

## ENCODE dataset characterisation and open region finding.

In this session we will also take some of the ENCODE data for Liver, Kidney and Hindbrain and perform a differential analysis on open regions.



---


## The Sequencing Data

In the ATACseq session we will make use of three sets of published data.

The first dataset is from original ATACseq paper.

Transposition of native chromatin for multimodal regulatory analysis and personal epigenomics
Jason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf

In particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 
Data can be retrieved in fastq format from ENA  

* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)

---

For the second dataset we take ATACseq generated by Bing Ren at UCSD as part of the ENCODE consortium. 
Links to data and sample information are included in list below.

* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)

* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)

* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)

---
Finally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in last session so we can review some of the characteristics of ATACseq data alongside the same data processed by ENCODE's pipeline during the practical session.

The raw data and processed BAM file is available from ENCODEs portal

* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)

In todays practical we will work with some of the ATACseq data of T-regulatory cells from Christina Leslie's lab.

Aligned data as a BAM file [can be found here.](https://www.encodeproject.org/files/ENCFF053CGD/@@download/ENCFF053CGD.bam)


---
## Processed Data

We start with public sequencing data in links below and use reference data in Bioconductor.

Since some of these processing steps may take a little time i provide links to pre-processed results.

**Essentials**

BAM file and BAI index from our alignment/sorting/indexing.

* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  

* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. 

---
**Essentials**

Small BAM, peak calls and directory structure.

* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.

Once you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**

You should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. 

---
**Not essential**

Same as above but with BAMs for counting as well as small BAM, peak calls and directory structure.

* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.

Bigwigs for IGV.

* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. 

---
## ATACseq

<div align="center">
<img src="imgs/mnATAC.jpg" alt="offset" height="300" width="600">
</div>

* ATACseq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.

---
## ATACseq

Unlike with ChIP-seq where we know the target of IP, with ATAC-seq we know that a region is open/accessible but have no knowledge of what transcription factors may be present.

We briefly saw at the end of our last session how we may scan for a specific motif under our peaks using **matchPWM**.

In the upcoming sessions we will review how we can investigate motifs in ATAC-seq using motifmatchr.


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Motifs in ATACseq

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Post-alignment processing

---
"    
  )
  
}
```

---
## Known Motif sources.

Bioconductor provides two major sources of motifs as database packages.

These include:-

 * The [MotifDb](https://www.bioconductor.org/packages/release/bioc/html/MotifDb.html) package.
 * The JASPAR databases, [JASPAR2020](https://www.bioconductor.org/packages/release/data/annotation/html/JASPAR2020.html) being latest.


---
## The MotifDb

The MotifDB package collects motif information from a wide range of sources and stores them in a DB object for use in other Bioconductor.

```{r,eval=TRUE}
library(MotifDb)
MotifDb
```




---
## The MotifDb

The MotifDb object is special class of object called a **MotifList**.


```{r,eval=TRUE}
class(MotifDb)
```


---
## The MotifDb

Like standard List objects we can use length and names to get some information on our object


```{r,eval=TRUE}
length(MotifDb)
MotifNames <- names(MotifDb)
MotifNames[1:10]
```

---
## The MotifDb

We can also access information directly from our list using standard list accessors.

Here a **[** will subset to a single MotifList. Now we can see the information held in the MotifList a little more clearly.

```{r,eval=TRUE}
MotifDb[1]
```



---
## The MotifDb

A **[[** will subset to object within the element as with stamadrd lists. Here we extract the position probability matrix.


```{r,eval=TRUE}
MotifDb[[1]]
colSums(MotifDb[[1]])
```

---
## The MotifDb

We can extract a DataFrame of all the motif metadata information using the **values()** function.


```{r,eval=TRUE}
values(MotifDb)[1:2,]
```

---
## The MotifDb

We can use the **query** function to subset our MotifList by infomation in the metadata.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,"CTCF")
CTCFMotifs
```

---
## The MotifDb

For more specific queries, multiple words can be used for filtering.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,c("CTCF","hsapiens","jaspar2018"))
CTCFMotifs
```


---
## JASPAR2020 package

The JASPAR packages are updated more frequently and so may contain motifs not characterised in the MotifDb package.

We can load the **JASPAR** package as usual and review the object as before.

```{r,eval=TRUE}
library(JASPAR2020)
JASPAR2020
```

---
## JASPAR2020 And TFBSTools

To interact with JASPAR package we will make use of the **TFBSTools** package from the same lab.

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.

```{r,eval=TRUE}
library(TFBSTools)
```


---
## TFBSTools

The **TFBSTools** package provides the functions 

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.

Three useful functions available from TFBStools to interact with the JASPAR databases are the **getMatrixSet**, **getMatrixByID** and **getMatrixByID**

```{r,eval=FALSE,echo=TRUE}
?getMatrixByID
```


---
## TFBSTools

The **getMatrixByID** and **getMatrixByName** take the JASPAR DB object and a JASPAR ID or transcription factor name respectively.

These return a new object class **PFMatrix**.

```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByName(JASPAR2020,"GATA2")
```

---
## TFBSTools

As JASPAR IDs are unique we can select the exact motif we wanted.
```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByID(JASPAR2020,"MA0036.2")
```

---
## TFBSTools

List accessors will not work here but we can retrieve names using the **ID** function.

```{r,eval=TRUE,echo=TRUE}
ID(GATA2mat)
```


---
## TFBSTools

To get hold of the position frequency matrix we can use the **Matrix** or **as.matrix** functions.

```{r,eval=TRUE}
myMatrix <- Matrix(GATA2mat)
myMatrixToo <- as.matrix(myMatrix)
myMatrix
```

---
## Visualising motifs

The seqLogo package offers a simple and intuitive way of visualising our base frequencies within out motifs using the **seqLogo** function.

A simple seqLogo shows the relative frequency of a base at each motif position by the relative size of the base compared to other bases at the same position. 

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
require(seqLogo)
CTCFMotifs <- query(MotifDb,"MYC")
seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```



---
## Visualising motifs

To create a seqLogo we must supply a PPM matrix to the **seqLogo** function.

Here we set the **ic.scale** to FALSE to show the probability across the Y-axis

```{r,eval=TRUE}
library(seqLogo)
seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```


---
## Visualising motifs

It may be useful to plot the probabilities as information content.

Information content here will range from 0 to 2 Bits. Positions with equal probabilites for each base will score 0 and psitions with only 1 possible base will score 2. 

This allows you to quickly identify the important bases.

```{r,eval=TRUE}
library(seqLogo)
seqLogo(CTCFMotifs[[1]])
```

---

## Visualising motifs

The TFBSTools package and JASPAR provide us with point frequency matricies which we can't use directly in the seqLogo package

```{r,eval=TRUE}
myMatrix
```

---

## Visualising motifs

We can convert our point frequency matrix to a point probabilty matrix by simply dividing columns by their sum.

```{r,eval=TRUE,echo=TRUE}
ppm <- myMatrix/colSums(myMatrix)
ppm
```

---

## Visualising motifs

We can then plot the result matrix using seqLogo.

```{r,eval=TRUE,echo=TRUE}
seqLogo(ppm)
```

---

## Visualising motifs

Fortunely, TFBSTools has its own version of seqLogo function we can use with one of its own **ICMatrix** classes.

We simply need to convert our object with the **toICM()** function.

```{r,eval=TRUE,echo=TRUE}
GATA2_IC <- toICM(GATA2mat)
TFBSTools::seqLogo(GATA2_IC)
```

---

## Visualising with ggplot

We could also take advantage of ggplot2 style grammer of graphics by using the **ggseqlogo** package.

```{r,eval=TRUE,echo=TRUE}
library(ggseqlogo)
library(ggplot2)
ggseqlogo(myMatrix)+theme_minimal()
```

---

```{r,eval=FALSE,echo=FALSE}
require(tidyverse)
require(DESeq2)
load("/Volumes/TomBackup/Temp/rui_ATAC_IL12combined_hg38/salmon/Antibody_ATAC_fromMACSisBlacklisted/ATAC/dds.RData")
ddsFilt <- dds[,colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm")]
colData(ddsFilt) <- colData(dds)[colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm"),]
colData(ddsFilt)$Group <- droplevels(colData(ddsFilt)$Group)
dds <- DESeq(ddsFilt)
myRes <- results(dds,contrast = c("Group","ATAC_Control","ATAC_Tbet_mm"))
myRes <- myRes[order(myRes$padj),]
upRegions <- rownames(myRes)[myRes$log2FoldChange > 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
# upRegions <- rownames(myRes)[myRes$log2FoldChange > 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
downRegions <- rownames(myRes)[myRes$log2FoldChange < 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges

# DownRegions <- rownames(myRes)[myRes$log2FoldChange < 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges


library(BSgenome.Hsapiens.UCSC.hg38)
upStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(upRegions,fix = "center",width = 100))
downStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(downRegions,fix = "center",width = 100))
names(upStrings) <- as.character(resize(upRegions,fix = "center",width = 100))
names(downStrings) <- as.character(resize(downRegions,fix = "center",width = 100))
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")


require(motifmatchr)
require(JASPAR2018)


db <- file.path(system.file("extdata", package="JASPAR2018"),
                "JASPAR2018.sqlite")
opts <- list()
opts[["tax_group"]] <- "vertebrates"
opts[["collection"]] <- "CORE"
opts[["all_versions"]] <- FALSE
require(TFBSTools)
motifs <- getMatrixSet(db,opts)



motif_ixUp <- matchMotifs(motifs, upStrings)
motif_ixDown <- matchMotifs(motifs, downStrings)
totalsUp <- colSums(assay(motif_ixUp))
totalsDow <- colSums(assay(motif_ixDown))
total <- data.frame(totalsUp,totalsDow)
total[total == 0] <- 1
total$Diff <- total$totalsUp/total$totalsDow
total[order(total$Diff,decreasing = TRUE),]

IDtoGRanges <- function(IDs,asIGV=FALSE){
  if(!asIGV){
    IDmat <- data.frame(matrix(unlist(strsplit(IDs,":")),ncol = 4,byrow = T)[,-1])
    newSe <- GRanges(IDmat$X1,IRanges(as.numeric(as.vector(IDmat$X2)),as.numeric(as.vector(IDmat$X3))))
  }
  newSe
}

load("data/myCounts.RData")
# newDDS <- SummarizedExperiment(counts(dds,normalized=TRUE),
#                                rowData=NULL,
#                                rowRanges=IDtoGRanges(rownames(counts(dds))),
#                                colData= colData(dds) %>%
#                                  as.data.frame %>%
#                                  cbind(data.frame(depth=colSums(counts(dds,normalized=FALSE)))) %>%
#                                  dplyr::select(-sizeFactor)
# )

newDDS <- myCounts
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney",
                  "Liver","Liver"))
colData(newDDS) <- DataFrame(data.frame(Group,row.names=colnames(myCounts)))
# 
# atacDDS <- DESeqDataSetFromMatrix(assay(myCounts),
#                                   metaData,
#                                   ~Group,
#                                   rowRanges=rowRanges(myCounts))

# names(sxs) <- gsub("\\s.*","",names(sxs))
assayNames(newDDS) <- "counts"
require(chromVAR)
newDDS <- newDDS[rowSums(assay(newDDS)) > 5,]
require(BSgenome.Mmusculus.UCSC.mm10)
newDDS <- addGCBias(newDDS,
                    genome = BSgenome.Mmusculus.UCSC.mm10)

motif_ix <- matchMotifs(motifs, newDDS,
                        genome = BSgenome.Mmusculus.UCSC.mm10)
dev_Known <- computeDeviations(object = newDDS, annotations = motif_ix)

variability_Known <- computeVariability(dev_Known) %>% arrange(p_value)

plotVariability(variability_Known, use_plotly = FALSE)
datatable(variability_Known)

temp <- deviationScores(dev_Known)
colnames(temp) <- paste0("Var_",colnames(temp))
mapOfIDs <- data.frame(id=names(rowData(dev_Known)$name),name=unname(rowData(dev_Known)$name))
sevew <- merge(mapOfIDs,temp,by.x=1,by.y=0)
sevew <- merge(variability_Known,sevew,by.x=1,by.y=2)
sigZ <- sevew %>% arrange(p_value) %>% 
  head(n=20) %>%
  mutate(newName=name) %>%
  dplyr::select(newName,starts_with("Var_")) %>%
  tibble::column_to_rownames("newName")
pheatmap(sigZ)
```

---
## Time for an exercise!

Exercise on ATACseq data can be found [here](../../exercises/exercises/ATACseq_part2_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/ATACseq_part2_answers.html)



