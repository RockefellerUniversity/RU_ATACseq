---
title: "ATACseq In Bioconductor <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_ATACseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
require(SummarizedExperiment)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# ATACseq (part 2)

---
"    
  )
  
}

```

```{r setup, include=FALSE}
library(motifmatchr)
library(MotifDb)
library(JASPAR2020)

```

## Greenleaf dataset characterisation and open region finding

In this section we will work a little more with the Greenleaf dataset. 

We will characterise Greenleaf data signal around TSS regions and identify and annotated open regions as peak calls using MACS2.

At the end of the session we will look at plotting transposase cut-sites around DNA binding proteins.

---

## ENCODE dataset characterisation and open region finding.

In this session we will also take some of the ENCODE data for Liver, Kidney and Hindbrain and perform a differential analysis on open regions.



---


## The Sequencing Data

In the ATACseq session we will make use of three sets of published data.

The first dataset is from original ATACseq paper.

Transposition of native chromatin for multimodal regulatory analysis and personal epigenomics
Jason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf

In particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 
Data can be retrieved in fastq format from ENA  

* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)

---

For the second dataset we take ATACseq generated by Bing Ren at UCSD as part of the ENCODE consortium. 
Links to data and sample information are included in list below.

* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)

* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)

* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)

---
Finally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in last session so we can review some of the characteristics of ATACseq data alongside the same data processed by ENCODE's pipeline during the practical session.

The raw data and processed BAM file is available from ENCODEs portal

* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)

In todays practical we will work with some of the ATACseq data of T-regulatory cells from Christina Leslie's lab.

Aligned data as a BAM file [can be found here.](https://www.encodeproject.org/files/ENCFF053CGD/@@download/ENCFF053CGD.bam)


---
## Processed Data

We start with public sequencing data in links below and use reference data in Bioconductor.

Since some of these processing steps may take a little time i provide links to pre-processed results.

**Essentials**

BAM file and BAI index from our alignment/sorting/indexing.

* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  

* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. 

---
**Essentials**

Small BAM, peak calls and directory structure.

* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.

Once you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**

You should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. 

---
**Not essential**

Same as above but with BAMs for counting as well as small BAM, peak calls and directory structure.

* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.

Bigwigs for IGV.

* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. 

---
## ATACseq

<div align="center">
<img src="imgs/mnATAC.jpg" alt="offset" height="300" width="600">
</div>

* ATACseq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.

---
## ATACseq

Unlike with ChIP-seq where we know the target of IP, with ATAC-seq we know that a region is open/accessible but have no knowledge of what transcription factors may be present.

We briefly saw at the end of our last session how we may scan for a specific motif under our peaks using **matchPWM**.

In the upcoming sessions we will review how we can investigate motifs in ATAC-seq using motifmatchr.


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Motifs in ATACseq

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Post-alignment processing

---
"    
  )
  
}
```

---
## Known Motif sources.

Bioconductor provides two major sources of motifs as database packages.

These include:-

 * The [MotifDb](https://www.bioconductor.org/packages/release/bioc/html/MotifDb.html) package.
 * The JASPAR databases, [JASPAR2020](https://www.bioconductor.org/packages/release/data/annotation/html/JASPAR2020.html) being latest.


---
## The MotifDb

The MotifDB package collects motif information from a wide range of sources and stores them in a DB object for use in other Bioconductor.

```{r,eval=TRUE}
library(MotifDb)
MotifDb
```




---
## The MotifDb

The MotifDb object is special class of object called a **MotifList**.


```{r,eval=TRUE}
class(MotifDb)
```


---
## The MotifDb

Like standard List objects we can use length and names to get some information on our object


```{r,eval=TRUE}
length(MotifDb)
MotifNames <- names(MotifDb)
MotifNames[1:10]
```

---
## The MotifDb

We can also access information directly from our list using standard list accessors.

Here a **[** will subset to a single MotifList. Now we can see the information held in the MotifList a little more clearly.

```{r,eval=TRUE}
MotifDb[1]
```



---
## The MotifDb

A **[[** will subset to object within the element as with stamadrd lists. Here we extract the position probability matrix.


```{r,eval=TRUE}
MotifDb[[1]]
colSums(MotifDb[[1]])
```

---
## The MotifDb

We can extract a DataFrame of all the motif metadata information using the **values()** function.


```{r,eval=TRUE}
values(MotifDb)[1:2,]
```

---
## The MotifDb

We can use the **query** function to subset our MotifList by infomation in the metadata.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,"CTCF")
CTCFMotifs
```

---
## The MotifDb

For more specific queries, multiple words can be used for filtering.


```{r,eval=TRUE}
CTCFMotifs <- query(MotifDb,c("CTCF","hsapiens","jaspar2018"))
CTCFMotifs
```


---
## JASPAR2020 package

The JASPAR packages are updated more frequently and so may contain motifs not characterised in the MotifDb package.

We can load the **JASPAR** package as usual and review the object as before.

```{r,eval=TRUE}
library(JASPAR2020)
JASPAR2020
```

---
## JASPAR2020 And TFBSTools

To interact with JASPAR package we will make use of the **TFBSTools** package from the same lab.

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.

```{r,eval=TRUE}
library(TFBSTools)
```


---
## TFBSTools

The **TFBSTools** package provides the functions 

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.

Three useful functions available from TFBStools to interact with the JASPAR databases are the **getMatrixSet**, **getMatrixByID** and **getMatrixByID**

```{r,eval=FALSE,echo=TRUE}
?getMatrixByID
```


---
## TFBSTools

The **getMatrixByID** and **getMatrixByName** take the JASPAR DB object and a JASPAR ID or transcription factor name respectively.

These return a new object class **PFMatrix**.

```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByName(JASPAR2020,"GATA2")
```

---
## TFBSTools

As JASPAR IDs are unique we can select the exact motif we wanted.
```{r,eval=TRUE,echo=TRUE}
GATA2mat <- getMatrixByID(JASPAR2020,"MA0036.2")
```

---
## TFBSTools

List accessors will not work here but we can retrieve names using the **ID** function.

```{r,eval=TRUE,echo=TRUE}
ID(GATA2mat)
```


---
## TFBSTools

To get hold of the position frequency matrix we can use the **Matrix** or **as.matrix** functions.

```{r,eval=TRUE}
myMatrix <- Matrix(GATA2mat)
myMatrixToo <- as.matrix(myMatrix)
myMatrix
```

---
## TFBSTools

We can also use the **getMatrixSet()** function to retrieve sets of motifs under user-specificed filters specified as a list.

To see the available filters use the help for getMatrixSet() function, ?getMatrixSet.

```{r,eval=TRUE}
?getMatrixSet
```

---
## TFBSTools

We can specify a list of options for motifs we want to retrieve.

```{r,eval=TRUE}
opts <- list()
opts[["collection"]] <- "CORE"
opts[["tax_group"]] <- "vertebrates"
motifList <- getMatrixSet(JASPAR2020, opts)
   
```


---
## Visualising motifs

The seqLogo package offers a simple and intuitive way of visualising our base frequencies within out motifs using the **seqLogo** function.

A simple seqLogo shows the relative frequency of a base at each motif position by the relative size of the base compared to other bases at the same position. 

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
require(seqLogo)
CTCFMotifs <- query(MotifDb,"MYC")
seqLogo::seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```



---
## Visualising motifs

To create a seqLogo we must supply a PPM matrix to the **seqLogo** function.

Here we set the **ic.scale** to FALSE to show the probability across the Y-axis

```{r,eval=TRUE}
library(seqLogo)
seqLogo::seqLogo(CTCFMotifs[[1]],ic.scale = FALSE)
```


---
## Visualising motifs

It may be useful to plot the probabilities as information content.

Information content here will range from 0 to 2 Bits. Positions with equal probabilites for each base will score 0 and psitions with only 1 possible base will score 2. 

This allows you to quickly identify the important bases.

```{r,eval=TRUE}
library(seqLogo)
seqLogo::seqLogo(CTCFMotifs[[1]])
```

---

## Visualising motifs

The TFBSTools package and JASPAR provide us with point frequency matricies which we can't use directly in the seqLogo package

```{r,eval=TRUE}
myMatrix
```

---

## Visualising motifs

We can convert our point frequency matrix to a point probabilty matrix by simply dividing columns by their sum.

```{r,eval=TRUE,echo=TRUE}
ppm <- myMatrix/colSums(myMatrix)
ppm
```

---

## Visualising motifs

We can then plot the result matrix using seqLogo.

```{r,eval=TRUE,echo=TRUE}
seqLogo::seqLogo(ppm)
```

---

## Visualising motifs

Fortunely, TFBSTools has its own version of seqLogo function we can use with one of its own **ICMatrix** classes.

We simply need to convert our object with the **toICM()** function.

```{r,eval=TRUE,echo=TRUE}
GATA2_IC <- toICM(GATA2mat)
TFBSTools::seqLogo(GATA2_IC)
```

---

## Visualising with ggplot

We could also take advantage of ggplot2 style grammer of graphics by using the **ggseqlogo** package.

```{r,eval=TRUE,echo=TRUE}
library(ggseqlogo)
library(ggplot2)
ggseqlogo(myMatrix)+theme_minimal()
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Identifying Motifs in ATAC

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Identifying Motifs in ATAC

---
"    
  )
  
}
```


---

## Known motif identification

Since ATAC-seq only tells us which regions are open/accessible, we can use motifs within our ATAC-seq peak regions to identify potential transcription factors which may be acting there

The databases such as MotifDb and JASPAR2020, provide sets of known motif patterns for us to use our motif identification.

---

## motifmatchr

To identify known motifs we will use the **motifmatchr** package which is a wrapper for the MOODS c++ library.

This means that motifmatchr offers us a fast methods to identify motifs within our ATAC-seq data.

We will use motifmatchr/MOODs with a default p-value cut-off.

---

## motifmatchr

First we can retrieve a sensible set of motifs to scan for within our mouse tissue ATAC-seq data.

Here we retrieve the vertebrate, JASPAR CORE motifs. We additional specify *all_versions* is FALSE to only include the latest version of a motif.

```{r}
opts <- list()
opts[["tax_group"]] <- "vertebrates"
opts[["collection"]] <- "CORE"
opts[["all_versions"]] <- FALSE
motifsToScan <- getMatrixSet(JASPAR2020,opts)

```


---

## motifmatchr

The motifmatchr package main function is **matchMotifs()**,

As with many Bioconductor functions , **matchMotifs** makes use of other Biocondcutor objects such the BSGenome, GRanges and SummarisedExperiment objects.

We can review the full functionality by reading the help for matchMotifs, ?matchMotifs.

```{r}
?matchMatifs.
```

---

## Tissue ATAC data

We need some data to review so we can make use of the Encode mouse tissue ATAC data from our previous sessions. 

We can load in the counts in a SummarisedExperiment object from the **data** directory.

```{r}
load("data/myCounts.RData")
myCounts
```


---

## Tissue ATAC data

We can retrieve the ranges of our peaks directly from our SummarizedExperiment object by using the standard accessor **rowRanges**.

```{r}
peakRanges <- rowRanges(myCounts)
peakRanges[1,]
```

---

## Tissue ATAC data

We have seen previous we can use the **getSeq()** function to extract sequences from a BSGenome object using a GRanges object to define the regions of interest. 

We load the BSgenome.Mmusculus.UCSC.mm10 library and re-center our peaks to 100bp using the resize function. Once resized we can extract the required sequences using the **getSeq()** function.

```{r}
library(BSgenome.Mmusculus.UCSC.mm10)
peakRangesCentered <- resize(peakRanges,fix = "center",width = 100)
peakSeqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10,peakRangesCentered)
names(peakSeqs) <- as.character(peakRangesCentered)
peakSeqs
```

---

## Finding motif positions.

As we saw in its help, The matchMotifs function can provide output of motif matches as matches, scores or positions.

Here we scan for 3 selected motifs from JASPAR2020 using the sequence under the first 100 ATAC-seq peaks and specify the out as **positions**

```{r}
motif_positions <- matchMotifs(motifsToScan[1:4], peakSeqs[1:100],out="positions")
class(motif_positions)
length(motif_positions)
```

---

## Finding motif positions.

The result contains a list of the same length as the number of motifs tested.

Each element contains a IRangeslist with an entry for every sequence tested and a IRanges of motif positions withins sequences

```{r}
motif_positions$MA0029.1
```

---

## Finding motif positions.

We can unlist our IRangeslist to a standard list for easier working.
```{r}

MA0029hits <- motif_positions$MA0029.1
names(MA0029hits) <- names(peakSeqs[1:100])
unlist(MA0029hits,use.names = TRUE)
```


---

## Finding motif hits

We may simply want to map motifs to their ATAC-seq peaks.

To do this we can set the **out** parameter to **matches**.  This will return a SummarizedExperiment object.

```{r}
motifHits <- matchMotifs(motifsToScan, peakSeqs,out="matches")
class(motifHits)
motifHits
```

---

## Finding motif hits

We can retrieve a matrix of matches by motif and peak using the motifMatches function.

```{r}
mmMatrix <- motifMatches(motifHits)
mmMatrix[1:8,1:8]
```

---

## Finding motif hits

Although a sparse matrix, we can still use our matrix operations to extract useful information from this object.

We can use the colsums to identify the total occurrence of motifs in our peak sequences.

```{r,eval=FALSE}
totalMotifOccurence <- colSums(mmMatrix)
totalMotifOccurence[1:4]
```

---

## Finding motif hits

We can also identify peaks which contain a hit for a selected motif.


```{r,eval=FALSE}
peaksWithMA0912 <- peakRangesCentered[mmMatrix[,"MA0912.2"] == 1]
peaksWithMA0912
```

---

## Summarising ATAC signal to Motifs

The **chromVar** package allows for the summarisation of ATAC-seq signal changes to the motifs within peaks.

With this summarisation we can potentially identify whith motifs may have an important role in a set of ATAC samples compared to other samples.

The chromVar package comes from the same lab and author as the motifmatchR package and so will work well together.

First we load the library.


```{r}
library(chromVAR)
```

---

## Summarising ATAC signal to Motifs

To identify motifs for chomVar we will use motifMatchr with a different set of inputs. 

Here we will provide our *Ranged*SummarizedExperiment object directly to the matchMotifs function. 

First we will remove any peaks with less than 5 reads across all samples.


```{r}
myCounts <- myCounts[rowSums(assay(myCounts)) > 5,]
```

---

## Summarising ATAC signal to Motifs


Next we can correct for any potential GC bias which may have arisen in sequencing. Previously we have seen that we have GC bias observable in our FastQ quality checks. 

For comparing across differing sets of peaks with differing sequences compositions we will need to correct for this bias. We can use the **addGCBias** and specify our genome as a BSgenome object to correct in chromVar.

```{r}
myCounts <- addGCBias(myCounts,
                    genome = BSgenome.Mmusculus.UCSC.mm10)
```


---

## Summarising ATAC signal to Motifs

Having corrected for bias, we can use the matchMotifs function again to identify motifs under our ATAC-seq peaks. 

Here we supply our *Ranged*SummarizedExperiment and the genome of interest to the **matchMotifs** function and use the default **out** of *matches*.

```{r}
motif_ix <- matchMotifs(motifsToScan, myCounts,
                        genome = BSgenome.Mmusculus.UCSC.mm10)
motif_ix
```

---

## Summarising ATAC signal to Motifs

Following the identification of motifs in our peaks, we can perform the summarisation of ATAC-seq signal to motifs using the **computeDeviations** and the **computeVariability** functions.

```{r,eval=FALSE}
deviations <- computeDeviations(object = myCounts, annotations = motif_ix)
variability_Known <- computeVariability(deviations)
```

```{r,include=FALSE}
load("data/deviations.RData")
load("data/variability.RData")
```


---

## Summarising ATAC signal to Motifs

The deviations result contains a SummarizedExperiment object with the Z-scores shwoing the enrichment for ATAC-seq signal in each sample for every motif.

```{r}
devZscores <- deviationScores(deviations)
devZscores[1:2,]
```


---

## Summarising ATAC signal to Motifs

The variabilty result contains the ranking of motifs by their variability across samples. Highly variable motifs may indicate motifs assocaited with a particualr sample group or variable across all groups.

```{r}
variability_Known <- variability_Known[order(variability_Known$p_value),]
variability_Known[1:10,]
```

---

## Summarising ATAC signal to Motifs

We can use the results from the variability with our Zscore deviations to identify in which sample our motifs are enriched.

```{r}
topVariable <- variability_Known[1:20,]
devTop <- merge(topVariable[,1,drop=FALSE],devZscores,by=0)
devTop[1:2,]
```


---

## Summarising ATAC signal to Motifs

A useful way to visualise these results is using a heatmap. Although we cover this in a later session, here we can use the **pheatmap** library with default settings to illustrate where our most variable motifs are active. 

```{r}
devToPlot <- as.matrix(devTop[,-c(1:2)])
rownames(devToPlot) <- devTop[,2]
library(pheatmap)
pheatmap(devToPlot)
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Identifying Motifs in ATAC

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Identifying Motifs in ATAC

---
"    
  )
  
}
```

---

## Denovo Motifs.

So far we have revied how to identify known motifs within our ATAC-seq peaks.

Previously we have seen that we can use the Meme-ChIP software to perform denovo motif identifation.

Here we wll use the Meme-ChIP software in a discriminative mode to identify denove motifs enriched in one set of samples over another.


---

## Denovo Motifs.

First we will need to identify a set of peaks enriched for ATAC-seq signal in one group over another. To do this we will use DESeq2 to identify ATAC-seq peaks enriched in 1 set over another.

We can load our Liver, Kindey and Brain counts from earlier into a DEseq object for differential analysis.

```{r}
require(DESeq2)
load("data/myCounts.RData")
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney",
                  "Liver","Liver"))
colData(myCounts) <- DataFrame(data.frame(Group,row.names=colnames(myCounts)))
dds <- DESeqDataSet(myCounts,design=~Group)
dds <- DESeq(dds)
```

---

## Denovo Motifs.

We can then use the DESeq2 function **results** to identify differential ATAC regions and set the **format** parameter to **GRanges** to allow the return of the result as a GRanges object.

```{r}
myRes <- results(dds,contrast = c("Group","Liver","Kidney"),format = "GRanges")
myRes <- myRes[order(myRes$padj),]
upRegions <- myRes[myRes$log2FoldChange > 0][1:1000] 
downRegions <- myRes[myRes$log2FoldChange < 0,][1:1000]
upRegions
```

---

## Denovo Motifs.

For Meme-ChIP we will want to resize the regions to 100bp. By default Meme-ChIP will perform this trimming for us but to ensure it is in the centre we will do this upfront.

```{r}

upRegions <- resize(upRegions,fix = "center",width = 100)
downRegions <- resize(downRegions,fix = "center",width = 100)
```

---

## Denovo Motifs.

We can now use the **getSeq** function as previously to extract the signal from around within the GRange regions and write to a FASTA file for use in Meme-ChIP using the **writeXStringSet** function.

```{r}
library(BSgenome.Mmusculus.UCSC.mm10)
upStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,upRegions)
downStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,downRegions)
names(upStrings) <- as.character(upRegions)
names(downStrings) <- as.character(downRegions)
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")
```

---

## Denovo Motifs.

We can then submit the sample to the Meme-ChIP online submission form found [here](http://meme-suite.org/tools/meme-chip). 

In contrast to for ChIP-seq, here we will run this in Differential mode to compare our sequences in Liver enriched regions to those depleted in Liver.

The results can be found in **data/memeResult_LiverVsBrain**


---

## Denovo Motifs.

We may want to use the motifs discovered by Meme-ChIP in other Bioconductor software.

To do this we can use the **universalmotif** package.

```{r}
library(universalmotif)
```



## Denovo Motifs.

The **universalmotif** package provides lots of useful fucntions for importing motif sets. 

One useful and relevant function is the  **read_meme()** function.

```{r}
memeMotifs <- read_meme("data/memeResult_LiverVsBrain/combined.meme")
```

---

## Denovo Motifs.

The **universalmotif** package also provides functions to convert between motif objects from different package. Here we convert to TFBStools motif objects.

```{r}
memeMotifsTFBStools <- convert_motifs(memeMotifs,"TFBSTools-PWMatrix")
memeMotifsTFBStools
```

---

```{r,eval=FALSE,echo=FALSE}
require(tidyverse)
require(DESeq2)
load("/Volumes/TomBackup/Temp/rui_ATAC_IL12combined_hg38/salmon/Antibody_ATAC_fromMACSisBlacklisted/ATAC/dds.RData")
ddsFilt <- dds[,colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm")]
colData(ddsFilt) <- colData(dds)[colData(dds)$Group %in% c("ATAC_Control","ATAC_Tbet_mm"),]
colData(ddsFilt)$Group <- droplevels(colData(ddsFilt)$Group)
dds <- DESeq(ddsFilt)
myRes <- results(dds,contrast = c("Group","ATAC_Control","ATAC_Tbet_mm"))
myRes <- myRes[order(myRes$padj),]
upRegions <- rownames(myRes)[myRes$log2FoldChange > 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
# upRegions <- rownames(myRes)[myRes$log2FoldChange > 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges
downRegions <- rownames(myRes)[myRes$log2FoldChange < 0][1:500] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges

# DownRegions <- rownames(myRes)[myRes$log2FoldChange < 0 & myRes$padj < 0.05 & !is.na(myRes$padj)] %>% gsub("ID:","",.) %>% gsub(":","-",.) %>% sub("-",":",.) %>% GRanges


library(BSgenome.Hsapiens.UCSC.hg38)
upStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(upRegions,fix = "center",width = 100))
downStrings <- getSeq(BSgenome.Hsapiens.UCSC.hg38,resize(downRegions,fix = "center",width = 100))
names(upStrings) <- as.character(resize(upRegions,fix = "center",width = 100))
names(downStrings) <- as.character(resize(downRegions,fix = "center",width = 100))
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")


require(motifmatchr)
require(JASPAR2018)


db <- file.path(system.file("extdata", package="JASPAR2018"),
                "JASPAR2018.sqlite")
opts <- list()
opts[["tax_group"]] <- "vertebrates"
opts[["collection"]] <- "CORE"
opts[["all_versions"]] <- FALSE
require(TFBSTools)
motifs <- getMatrixSet(db,opts)



motif_ixUp <- matchMotifs(motifs, upStrings)
motif_ixDown <- matchMotifs(motifs, downStrings)
totalsUp <- colSums(assay(motif_ixUp))
totalsDow <- colSums(assay(motif_ixDown))
total <- data.frame(totalsUp,totalsDow)
total[total == 0] <- 1
total$Diff <- total$totalsUp/total$totalsDow
total[order(total$Diff,decreasing = TRUE),]

IDtoGRanges <- function(IDs,asIGV=FALSE){
  if(!asIGV){
    IDmat <- data.frame(matrix(unlist(strsplit(IDs,":")),ncol = 4,byrow = T)[,-1])
    newSe <- GRanges(IDmat$X1,IRanges(as.numeric(as.vector(IDmat$X2)),as.numeric(as.vector(IDmat$X3))))
  }
  newSe
}

load("data/myCounts.RData")
# newDDS <- SummarizedExperiment(counts(dds,normalized=TRUE),
#                                rowData=NULL,
#                                rowRanges=IDtoGRanges(rownames(counts(dds))),
#                                colData= colData(dds) %>%
#                                  as.data.frame %>%
#                                  cbind(data.frame(depth=colSums(counts(dds,normalized=FALSE)))) %>%
#                                  dplyr::select(-sizeFactor)
# )

newDDS <- myCounts
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney",
                  "Liver","Liver"))
colData(newDDS) <- DataFrame(data.frame(Group,row.names=colnames(myCounts)))
require(DESeq2)
require(tidyverse)
atacDDS <- DESeqDataSetFromMatrix(assay(myCounts),
                                  colData(newDDS),
                                  ~Group,
                                  rowRanges=rowRanges(myCounts))
atacDDS <- DESeq(atacDDS)
myRes <- results(atacDDS,contrast = c("Group","Liver","Kidney"),format = "GRanges")
myRes <- myRes[order(myRes$padj),]
upRegions <- myRes[myRes$log2FoldChange > 0][1:1000] 
downRegions <- myRes[myRes$log2FoldChange < 0,][1:1000]

library(BSgenome.Mmusculus.UCSC.mm10)
upStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,resize(upRegions,fix = "center",width = 100))
downStrings <- getSeq(BSgenome.Mmusculus.UCSC.mm10,resize(downRegions,fix = "center",width = 100))
names(upStrings) <- as.character(resize(upRegions,fix = "center",width = 100))
names(downStrings) <- as.character(resize(downRegions,fix = "center",width = 100))
writeXStringSet(upStrings,file="UpRegions.fa")
writeXStringSet(downStrings,file="DownStrings.fa")

# names(sxs) <- gsub("\\s.*","",names(sxs))
assayNames(newDDS) <- "counts"
require(chromVAR)
newDDS <- newDDS[rowSums(assay(newDDS)) > 5,]
require(BSgenome.Mmusculus.UCSC.mm10)
newDDS <- addGCBias(newDDS,
                    genome = BSgenome.Mmusculus.UCSC.mm10)

motif_ix <- matchMotifs(motifs, newDDS,
                        genome = BSgenome.Mmusculus.UCSC.mm10)
dev_Known <- computeDeviations(object = newDDS, annotations = motif_ix)

variability_Known <- computeVariability(dev_Known) %>% arrange(p_value)

plotVariability(variability_Known, use_plotly = FALSE)
datatable(variability_Known)

temp <- deviationScores(dev_Known)
colnames(temp) <- paste0("Var_",colnames(temp))
mapOfIDs <- data.frame(id=names(rowData(dev_Known)$name),name=unname(rowData(dev_Known)$name))
sevew <- merge(mapOfIDs,temp,by.x=1,by.y=0)
sevew <- merge(variability_Known,sevew,by.x=1,by.y=2)
sigZ <- sevew %>% arrange(p_value) %>% 
  head(n=20) %>%
  mutate(newName=name) %>%
  dplyr::select(newName,starts_with("Var_")) %>%
  tibble::column_to_rownames("newName")
pheatmap(sigZ)
```

---
## Time for an exercise!

Exercise on ATACseq data can be found [here](../../exercises/exercises/ATACseq_part2_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/ATACseq_part2_answers.html)



