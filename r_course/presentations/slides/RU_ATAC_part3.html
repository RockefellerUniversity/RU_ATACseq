<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>RU_ATAC_part3.utf8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# ATACseq In Bioconductor
<html>
<div style="float:left">

</div>
<hr color='#EB811B' size=1px width=796px>
</html>
### Rockefeller University, Bioinformatics Resource Centre
### <a href="http://rockefelleruniversity.github.io/RU_ATACseq/" class="uri">http://rockefelleruniversity.github.io/RU_ATACseq/</a>

---








## Greenleaf dataset characterisation and open region finding

In this section we will work a little more with the Greenleaf dataset. 

We will characterise Greenleaf data signal around TSS regions and identify and annotated open regions as peak calls using MACS2.

At the end of the session we will look at plotting transposase cut-sites around DNA binding proteins.

---

## ENCODE dataset characterisation and open region finding.

In this session we will also take some of the ENCODE data for Liver, Kidney and Hindbrain and perform a differential analysis on open regions.



---


## The Sequencing Data

In the ATACseq session we will make use of three sets of published data.

The first dataset is from original ATACseq paper.

Transposition of native chromatin for multimodal regulatory analysis and personal epigenomics
Jason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf

In particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 
Data can be retrieved in fastq format from ENA  

* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)

---

For the second dataset we take ATACseq generated by Bing Ren at UCSD as part of the ENCODE consortium. 
Links to data and sample information are included in list below.

* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)

* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)

* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)

---
Finally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in last session so we can review some of the characteristics of ATACseq data alongside the same data processed by ENCODE's pipeline during the practical session.

The raw data and processed BAM file is available from ENCODEs portal

* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)

In todays practical we will work with some of the ATACseq data of T-regulatory cells from Christina Leslie's lab.

Aligned data as a BAM file [can be found here.](https://www.encodeproject.org/files/ENCFF053CGD/@@download/ENCFF053CGD.bam)


---
## Processed Data

We start with public sequencing data in links below and use reference data in Bioconductor.

Since some of these processing steps may take a little time i provide links to pre-processed results.

**Essentials**

BAM file and BAI index from our alignment/sorting/indexing.

* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  

* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. 

---
**Essentials**

Small BAM, peak calls and directory structure.

* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.

Once you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**

You should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. 

---
**Not essential**

Same as above but with BAMs for counting as well as small BAM, peak calls and directory structure.

* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.

Bigwigs for IGV.

* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. 

---
## ATACseq

&lt;div align="center"&gt;
&lt;img src="imgs/mnATAC.jpg" alt="offset" height="300" width="600"&gt;
&lt;/div&gt;

* ATACseq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.

---
## ATACseq

Unlike with ChIP-seq where we know the target of IP, with ATAC-seq we know that a region is open/accessible but have no knowledge of what transcription factors may be present.

We briefly saw at the end of our last session how we may scan for a specific motif under our peaks using **matchPWM**.

In the upcoming sessions we will review how we can investigate motifs in ATAC-seq using motifmatchr.


---
class: inverse, center, middle

# Motifs in ATACseq

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

---
## Known Motif sources.

Bioconductor provides two major sources of motifs as database packages.

These include:-

 * The [MotifDb](https://www.bioconductor.org/packages/release/bioc/html/MotifDb.html) package.
 * The JASPAR databases, [JASPAR2020](https://www.bioconductor.org/packages/release/data/annotation/html/JASPAR2020.html) being latest.


---
## The MotifDb

The MotifDB package collects motif information from a wide range of sources and stores them in a DB object for use in other Bioconductor.


```r
library(MotifDb)
MotifDb
```

```
## MotifDb object of length 10701
## | Created from downloaded public sources: 2013-Aug-30
## | 10701 position frequency matrices from 21 sources:
## |         cisbp_1.02:  874
## |    FlyFactorSurvey:  614
## |        HOCOMOCOv10: 1066
## | HOCOMOCOv11-core-A:  181
## | HOCOMOCOv11-core-B:   84
## | HOCOMOCOv11-core-C:  135
## | HOCOMOCOv11-secondary-A:   46
## | HOCOMOCOv11-secondary-B:   19
## | HOCOMOCOv11-secondary-C:   13
## | HOCOMOCOv11-secondary-D:  290
## |              HOMER:  332
## |               hPDI:  437
## |        JASPAR_2014:  592
## |        JASPAR_CORE:  459
## |         jaspar2016: 1209
## |         jaspar2018: 1564
## |          jolma2013:  843
## |             ScerTF:  196
## |            stamlab:  683
## |       SwissRegulon:  684
## |           UniPROBE:  380
## | 61 organism/s
## |           Hsapiens: 5384
## |          Mmusculus: 1411
## |      Dmelanogaster: 1287
## |        Scerevisiae: 1051
## |          Athaliana:  803
## |           Celegans:   90
## |              other:  675
## Scerevisiae-cisbp_1.02-M0001_1.02 
## Scerevisiae-cisbp_1.02-M0002_1.02 
## Scerevisiae-cisbp_1.02-M0003_1.02 
## Csativa-cisbp_1.02-M0004_1.02 
## Athaliana-cisbp_1.02-M0005_1.02 
## ...
## Mmusculus-UniPROBE-Zfp740.UP00022 
## Mmusculus-UniPROBE-Zic1.UP00102 
## Mmusculus-UniPROBE-Zic2.UP00057 
## Mmusculus-UniPROBE-Zic3.UP00006 
## Mmusculus-UniPROBE-Zscan4.UP00026
```




---
## The MotifDb

The MotifDb object is special class of object called a **MotifList**.



```r
class(MotifDb)
```

```
## [1] "MotifList"
## attr(,"package")
## [1] "MotifDb"
```


---
## The MotifDb

Like standard List objects we can use length and names to get some information on our object



```r
length(MotifDb)
```

```
## [1] 10701
```

```r
MotifNames &lt;- names(MotifDb)
MotifNames[1:10]
```

```
##  [1] "Scerevisiae-cisbp_1.02-M0001_1.02" "Scerevisiae-cisbp_1.02-M0002_1.02"
##  [3] "Scerevisiae-cisbp_1.02-M0003_1.02" "Csativa-cisbp_1.02-M0004_1.02"    
##  [5] "Athaliana-cisbp_1.02-M0005_1.02"   "Athaliana-cisbp_1.02-M0006_1.02"  
##  [7] "Athaliana-cisbp_1.02-M0007_1.02"   "Athaliana-cisbp_1.02-M0008_1.02"  
##  [9] "Athaliana-cisbp_1.02-M0009_1.02"   "Athaliana-cisbp_1.02-M0010_1.02"
```

---
## The MotifDb

We can also access information directly from our list using standard list accessors.

Here a **[** will subset to a single MotifList. Now we can see the information held in the MotifList a little more clearly.


```r
MotifDb[1]
```

```
## MotifDb object of length 1
## | Created from downloaded public sources: 2013-Aug-30
## | 1 position frequency matrices from 1 source:
## |         cisbp_1.02:    1
## | 1 organism/s
## |        Scerevisiae:    1
## Scerevisiae-cisbp_1.02-M0001_1.02
```



---
## The MotifDb

A **[[** will subset to object within the element as with stamadrd lists. Here we extract the position probability matrix.



```r
MotifDb[[1]]
```

```
##             1           2           3           4           5           6
## A 0.009615385 0.009615385 0.971153846 0.009615385 0.009615385 0.971153846
## C 0.009615385 0.009615385 0.009615385 0.009615385 0.971153846 0.009615385
## G 0.009615385 0.009615385 0.009615385 0.009615385 0.009615385 0.009615385
## T 0.971153846 0.971153846 0.009615385 0.971153846 0.009615385 0.009615385
##             7           8
## A 0.009615385 0.009615385
## C 0.971153846 0.009615385
## G 0.009615385 0.009615385
## T 0.009615385 0.971153846
```

```r
colSums(MotifDb[[1]])
```

```
## 1 2 3 4 5 6 7 8 
## 1 1 1 1 1 1 1 1
```

---
## The MotifDb

We can extract a DataFrame of all the motif metadata information using the **values()** function.



```r
values(MotifDb)[1:2, ]
```

```
## DataFrame with 2 rows and 15 columns
##                                   providerName     providerId  dataSource
##                                    &lt;character&gt;    &lt;character&gt; &lt;character&gt;
## Scerevisiae-cisbp_1.02-M0001_1.02   M0001_1.02 MA0000004_1.02  cisbp_1.02
## Scerevisiae-cisbp_1.02-M0002_1.02   M0002_1.02 MA0000135_1.02  cisbp_1.02
##                                    geneSymbol      geneId  geneIdType
##                                   &lt;character&gt; &lt;character&gt; &lt;character&gt;
## Scerevisiae-cisbp_1.02-M0001_1.02        ABF1          NA          NA
## Scerevisiae-cisbp_1.02-M0002_1.02        AFT1          NA          NA
##                                     proteinId proteinIdType    organism
##                                   &lt;character&gt;   &lt;character&gt; &lt;character&gt;
## Scerevisiae-cisbp_1.02-M0001_1.02     YKL112W           SGD Scerevisiae
## Scerevisiae-cisbp_1.02-M0002_1.02     YGL071W           SGD Scerevisiae
##                                   sequenceCount bindingSequence bindingDomain
##                                     &lt;character&gt;     &lt;character&gt;   &lt;character&gt;
## Scerevisiae-cisbp_1.02-M0001_1.02            NA              NA            NA
## Scerevisiae-cisbp_1.02-M0002_1.02            NA              NA            NA
##                                      tfFamily experimentType    pubmedID
##                                   &lt;character&gt;    &lt;character&gt; &lt;character&gt;
## Scerevisiae-cisbp_1.02-M0001_1.02        ABF1             NA    19111667
## Scerevisiae-cisbp_1.02-M0002_1.02         AFT             NA    19158363
```

---
## The MotifDb

We can use the **query** function to subset our MotifList by infomation in the metadata.



```r
CTCFMotifs &lt;- query(MotifDb, "CTCF")
CTCFMotifs
```

```
## MotifDb object of length 19
## | Created from downloaded public sources: 2013-Aug-30
## | 19 position frequency matrices from 9 sources:
## |        HOCOMOCOv10:    3
## | HOCOMOCOv11-core-A:    2
## |              HOMER:    3
## |        JASPAR_2014:    2
## |        JASPAR_CORE:    1
## |         jaspar2016:    2
## |         jaspar2018:    3
## |          jolma2013:    1
## |       SwissRegulon:    2
## | 4 organism/s
## |           Hsapiens:   12
## |      Dmelanogaster:    3
## |          Mmusculus:    1
## |              other:    3
## Hsapiens-HOCOMOCOv10-CTCFL_HUMAN.H10MO.A 
## Hsapiens-HOCOMOCOv10-CTCF_HUMAN.H10MO.A 
## Mmusculus-HOCOMOCOv10-CTCF_MOUSE.H10MO.A 
## Hsapiens-HOCOMOCOv11-core-A-CTCFL_HUMAN.H11MO.0.A 
## Hsapiens-HOCOMOCOv11-core-A-CTCF_HUMAN.H11MO.0.A 
## ...
## Dmelanogaster-jaspar2018-CTCF-MA0531.1 
## Hsapiens-jaspar2018-CTCFL-MA1102.1 
## Hsapiens-jolma2013-CTCF 
## Hsapiens-SwissRegulon-CTCFL.SwissRegulon 
## Hsapiens-SwissRegulon-CTCF.SwissRegulon
```

---
## The MotifDb

For more specific queries, multiple words can be used for filtering.



```r
CTCFMotifs &lt;- query(MotifDb, c("CTCF", "hsapiens", "jaspar2018"))
CTCFMotifs
```

```
## MotifDb object of length 2
## | Created from downloaded public sources: 2013-Aug-30
## | 2 position frequency matrices from 1 source:
## |         jaspar2018:    2
## | 1 organism/s
## |           Hsapiens:    2
## Hsapiens-jaspar2018-CTCF-MA0139.1 
## Hsapiens-jaspar2018-CTCFL-MA1102.1
```


---
## JASPAR2020 package

The JASPAR packages are updated more frequently and so may contain motifs not characterised in the MotifDb package.

We can load the **JASPAR** package as usual and review the object as before.


```r
library(JASPAR2020)
JASPAR2020
```

```
## An object of class "JASPAR2020"
## Slot "db":
## [1] "/usr/local/lib/R/host-site-library/JASPAR2020/extdata/JASPAR2020.sqlite"
```

---
## JASPAR2020 And TFBSTools

To interact with JASPAR package we will make use of the **TFBSTools** package from the same lab.

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.


```r
library(TFBSTools)
```

```
## 
## Attaching package: 'TFBSTools'
```

```
## The following object is masked from 'package:seqLogo':
## 
##     seqLogo
```

```
## The following object is masked from 'package:DelayedArray':
## 
##     matrixClass
```


---
## TFBSTools

The **TFBSTools** package provides the functions 

Whereas the JASPAR package holds the information on Motifs and PPMs, TFBSTools has the functionality to manipulate and interact with these tools.

Three useful functions available from TFBStools to interact with the JASPAR databases are the **getMatrixSet**, **getMatrixByID** and **getMatrixByID**


```r
`?`(getMatrixByID)
```


---
## TFBSTools

The **getMatrixByID** and **getMatrixByName** take the JASPAR DB object and a JASPAR ID or transcription factor name respectively.

These return a new object class **PFMatrix**.


```r
GATA2mat &lt;- getMatrixByName(JASPAR2020, "GATA2")
```

---
## TFBSTools

As JASPAR IDs are unique we can select the exact motif we wanted.

```r
GATA2mat &lt;- getMatrixByID(JASPAR2020, "MA0036.2")
```

---
## TFBSTools

List accessors will not work here but we can retrieve names using the **ID** function.


```r
ID(GATA2mat)
```

```
## [1] "MA0036.2"
```


---
## TFBSTools

To get hold of the position frequency matrix we can use the **Matrix** or **as.matrix** functions.


```r
myMatrix &lt;- Matrix(GATA2mat)
myMatrixToo &lt;- as.matrix(myMatrix)
myMatrix
```

```
##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## A 1569 1125 1555 1051   32    9    0   51 4380     0     0  1225   104  1256
## C  567  768  729  525 1057 3015  192    0    0     0  4380     0  1765  1185
## G  754 1709 1220  427  765  914    0    0    0     0     0     0  1967   224
## T 1490  778  876 2377 2526  442 4188 4329    0  4380     0  3155   544  1715
```

---
## Visualising motifs

The seqLogo package offers a simple and intuitive way of visualising our base frequencies within out motifs using the **seqLogo** function.

A simple seqLogo shows the relative frequency of a base at each motif position by the relative size of the base compared to other bases at the same position. 

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;



---
## Visualising motifs

To create a seqLogo we must supply a PPM matrix to the **seqLogo** function.

Here we set the **ic.scale** to FALSE to show the probability across the Y-axis


```r
library(seqLogo)
seqLogo::seqLogo(CTCFMotifs[[1]], ic.scale = FALSE)
```

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;


---
## Visualising motifs

It may be useful to plot the probabilities as information content.

Information content here will range from 0 to 2 Bits. Positions with equal probabilites for each base will score 0 and psitions with only 1 possible base will score 2. 

This allows you to quickly identify the important bases.


```r
library(seqLogo)
seqLogo::seqLogo(CTCFMotifs[[1]])
```

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---

## Visualising motifs

The TFBSTools package and JASPAR provide us with point frequency matricies which we can't use directly in the seqLogo package


```r
myMatrix
```

```
##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## A 1569 1125 1555 1051   32    9    0   51 4380     0     0  1225   104  1256
## C  567  768  729  525 1057 3015  192    0    0     0  4380     0  1765  1185
## G  754 1709 1220  427  765  914    0    0    0     0     0     0  1967   224
## T 1490  778  876 2377 2526  442 4188 4329    0  4380     0  3155   544  1715
```

---

## Visualising motifs

We can convert our point frequency matrix to a point probabilty matrix by simply dividing columns by their sum.


```r
ppm &lt;- myMatrix/colSums(myMatrix)
ppm
```

```
##        [,1]      [,2]      [,3]       [,4]        [,5]        [,6]       [,7]
## A 0.3582192 0.2568493 0.3550228 0.23995434 0.007305936 0.002054795 0.00000000
## C 0.1294521 0.1753425 0.1664384 0.11986301 0.241324201 0.688356164 0.04383562
## G 0.1721461 0.3901826 0.2785388 0.09748858 0.174657534 0.208675799 0.00000000
## T 0.3401826 0.1776256 0.2000000 0.54269406 0.576712329 0.100913242 0.95616438
##         [,8] [,9] [,10] [,11]     [,12]      [,13]      [,14]
## A 0.01164384    1     0     0 0.2796804 0.02374429 0.28675799
## C 0.00000000    0     0     1 0.0000000 0.40296804 0.27054795
## G 0.00000000    0     0     0 0.0000000 0.44908676 0.05114155
## T 0.98835616    0     1     0 0.7203196 0.12420091 0.39155251
```

---

## Visualising motifs

We can then plot the result matrix using seqLogo.


```r
seqLogo::seqLogo(ppm)
```

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;

---

## Visualising motifs

Fortunely, TFBSTools has its own version of seqLogo function we can use with one of its own **ICMatrix** classes.

We simply need to convert our object with the **toICM()** function.


```r
GATA2_IC &lt;- toICM(GATA2mat)
TFBSTools::seqLogo(GATA2_IC)
```

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;

---

## Visualising with ggplot

We could also take advantage of ggplot2 style grammer of graphics by using the **ggseqlogo** package.


```r
library(ggseqlogo)
library(ggplot2)
ggseqlogo(myMatrix) + theme_minimal()
```

![](RU_ATAC_part3_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;



---
class: inverse, center, middle

# Identifying Motifs in ATAC

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


---

## Known motifs identification

Since ATAC-seq only tells us which regions are open/accessible, we can use motifs within our ATAC-seq peak regions to identify potential transcription factors which may be acting there

The databases such as MotifDb and JASPAR2020, provide sets of known motif patterns for us to use our motif identification.

---



---
## Time for an exercise!

Exercise on ATACseq data can be found [here](../../exercises/exercises/ATACseq_part2_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/ATACseq_part2_answers.html)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
